/**
 * Holds the components and terminals for an electric circuit. The solve() method finds the current through
 * and voltage across each component of the circuit. Handles dead-end branches of a circuit correctly,
 * but may not work correctly if circuit fragments or more than one complete circuit are present.
 * Set the instance variable "verbose" to true to display results of intermediate calculations.
 */
class Circuit {
    /**
     * Constructs a new Circuit object with a grid of terminals with particular dimensions
     * @param row The number of rows of terminals in the circuit
     * @param col The number of columns of terminals in the circuit
     */
    constructor(row, col) {
        this.rows = row;
        this.cols = col;
        this.terminals = new Array(this.rows);
        this.components = [];
        this.numBranches = 0;
        this.verbose = false;

        // initialize Terminals
        for (let r = 0; r < this.rows; r++) {
            this.terminals[r] = new Array(this.cols);
            for (let c = 0; c < this.cols; c++) {
                this.terminals[r][c] = new Terminal(r, c);
            }
        }
    }

    /**
     * Constructs a copy of a given circuit by adding in the same set of components. Information regarding
     * branches, currents, etc. will NOT be copied. These can be regenerated by using findNodes(),
     * labelBranches() and solve().
     * @param origCircuit The Circuit object that you wish to copy
     * @return Circuit: A copy of the origCircuit
     */
    clone(origCircuit) {
        const copy = new Circuit(origCircuit.getRows(), origCircuit.getCols());
        for (const comp of origCircuit.getComponents()) {
            // get endpoint row and column for component in original circuit
            const r1 = comp.getEndPt1().getRow();
            const c1 = comp.getEndPt1().getCol();
            const r2 = comp.getEndPt2().getRow();
            const c2 = comp.getEndPt2().getCol();

            if (comp instanceof Resistor) {
                copy.addComponent(new Resistor(comp.getResistance()), r1, c1, r2, c2);
            }
            else if (comp instanceof Wire) {
                copy.addComponent(new Wire(), r1, c1, r2, c2);
            }
            else if (comp instanceof Battery) {
                const batt = new Battery(comp.getVoltage());
                copy.addBattery(batt, r1, c1, r2, c2, comp.getPosEnd().getRow(), comp.getPosEnd().getCol());
            }
        }
        return copy;
    }

    /**
     * This method uses helper methods to:
     *     (1) populate the Array of nodes (junctions) for a circuit;
     *     (2) assign a current/branch number to each independent branch of the circuit; dead-ends are branch 999
     *     (3) assign a current-direction to each component within each branch;
     *     (4) populate an array of loops, wherein each loop is an array of the components in that loop;
     * @param nodes  Terminal[]: An empty array that will be populated with the terminals that are junctions in the circuit.
     * @param origloops  Component[][]: An empty array of arrays of components that will be populated with components from circuit loops.
     * @return int: The number of branches in the circuit, excluding any dead-end branches.
     */
    findNodesAndLoops(nodes, origLoops) {
        // Original circuit, including any dead-ends
        this.findNodes(nodes);
        this.labelBranches(nodes);
        if (this.numBranches === 0) {  // There is not a complete circuit
            return 0;
        }
        // A copy of the circuit that will have dead-ends removed.
        const equationCopy = this.clone(this);
        equationCopy.findNodes(nodes);
        equationCopy.labelBranches(nodes);
        let deadEnd = equationCopy.getComponents()[0]; // just to be not null
        while (deadEnd !== null) {  // Remove one dangling component at a time, until there are no more
            deadEnd = equationCopy.removeDangler();
            if (deadEnd !== null) {
                const orig = equationCopy.findCorrespondingComponent(this, deadEnd);
                orig.setBranch(999);
            }
        }

        equationCopy.findNodes(nodes);  // The nodes list is now properly updated for writing circuit equations.
        equationCopy.labelBranches(nodes);

        // Update original circuit with branch numbers and currentDirections from the copy that has had deadends trimmed off.
        for (let c of equationCopy.getComponents()) {
            const orig = this.findCorrespondingComponent(this, c);
            orig.setBranch(c.getBranch());
            orig.setCurrentDirection(c.getCurrentDirection());
        }

        // Make a copy of circuit and nodes that can be modified during the loop analysis. As loops are identified,
        // components will be removed from the copy circuit, so that different loops can be found.
        const copy = this.clone(equationCopy);
        const copyNodes = [];
        copy.findNodes(copyNodes);
        copy.labelBranches(copyNodes);

        this.numBranches = copy.getNumBranches();

        // Makes an array parallel to origLoops: an array of arrays of components within each loop.
        const copyLoops = []; // loops in the copy circuit, not the original circuit
        let loopCounter = 0;
        while (copy.getComponents().length > 0) {
            copyLoops.push([]);
            origLoops.push([]);
            //  make array of terminals in loop
            const copyTerms = [];
            let comp = copy.getComponents()[0];
            let prevTerm = comp.getEndPt1();
            copyTerms.push(prevTerm);
            let endLoop = false;
            while (!endLoop) {
                //walk around loop, adding terminals and components to their arrays
                copyLoops[loopCounter].push(comp);
                origLoops[loopCounter].push(this.findCorrespondingComponent(this, comp));  // corresponding component in orig circuit
                let nextTerm = comp.getEndPt2();
                if (nextTerm === prevTerm) {  // then nextTerm is not actually the next terminal in the loop...
                    nextTerm = comp.getEndPt1();    // so get the other end of the component
                }

                if (copyTerms.includes(nextTerm)) {  // you have reached a terminal you have seen before
                    endLoop = true;
                }
                else {   // get one of the connected components (that is not the component you just added to the loop)
                    let nextComp = nextTerm.getConnections()[0];
                    if (comp === nextComp) {
                        nextComp = nextTerm.getConnections()[1];
                    }
                    prevTerm = nextTerm;
                    comp = nextComp;
                }
                copyTerms.push(nextTerm);
            }
            // Once you find a terminal that is already in the loop, there may still be a dangling end at the start of the loop.
            // That is, it may be shaped like a "9". So trim off the initial components until the start and end terminals are the same.
            while (copyTerms[0] !== copyTerms[copyTerms.length - 1]) {
                //trim terminals and components off start of lists
                copyTerms.shift();
                copyLoops[loopCounter].shift();
                origLoops[loopCounter].shift();
            }
            // To find the next independent loop, remove a component (and dangling ends) from the loop you just found.
            // That way you won't find the exact same loop the next time.
            copy.removeComponent(copyLoops[loopCounter][0]);
            let dangler = copy.getComponents()[0]; // just to be not null;
            while (dangler !== null) {   // Remove one dangling component at a time, until there are no more
                dangler = copy.removeDangler();
            }
            loopCounter++;
        }
        return copy.getNumBranches();
    }

    /**
     * Searches the 2-D array of terminals to find junctions. Adds any terminals that have three or more connections
     * to a List of nodes. The provided list of nodes is first cleared, and then repopulated.
     * @param nodes  A reference to a List of terminals.
     */
    findNodes(nodes) {
        nodes.splice(0, nodes.length);  // empties the nodes array
        for (let r = 0; r < this.getRows(); r++) {
            for (let c = 0; c < this.getCols(); c++) {
                if (this.getTerminal(r, c).numConnections() > 2) {
                    nodes.push(this.getTerminal(r, c));
                }
            }
        }
    }

    /**
     * Labels each component in the circuit with a branch number. The currents through all components in a branch are the same,
     * so branch numbers correspond to current variables in the circuit equations. E.g. current[0] = current through components
     * labeled with branch 0. This method also assigns a current direction to each component within a branch. Branches that are
     * dead-ends are given the branch number 999. (May not identify all deadends.)
     * @param nodes  Array of Terminals: The List of nodes (junctions) in the circuit.
     * @return False if it finds no complete circuit; true otherwise.
     */
    labelBranches(nodes) {
        this.numBranches = 0;
        if (this.components.length === 0) {
            return false;
        }
        if (nodes.length === 0) {   // Circuit is a single loop without junctions (or a single incomplete circuit)
            let c = this.components[0];
            let prevTerm = c.getEndPt1();
            for (let i = 0; i < this.components.length; i++) {
                c.setBranch(0);     // only one loop, so all components are branch 0
                let nextTerminal = c.getEndPt2();
                if (nextTerminal === prevTerm) {   // make sure you get the terminal at the opposite end of the component
                    nextTerminal = c.getEndPt1();
                }
                if (nextTerminal.numConnections() < 2) {   // a dead end in the circuit
                    return false;
                }
                c.setCurrentDirection(nextTerminal);
                let nextComponent = nextTerminal.getConnection(0);
                if (nextComponent === c) {
                    nextComponent = nextTerminal.getConnection(1);
                }
                c = nextComponent;
                prevTerm = nextTerminal;
            }
            this.numBranches = 1;    // the complete loop is one branch: branch #0
        }
        else {   // there are multiple branches
            // Reset branch number of each component to -1, the default for unassigned branches
            for (let c of this.components) {
                c.setBranch(-1);
            }
            // loop through every connection of every node...
            for (let node of nodes) {
                for (let i = 0; i < node.numConnections(); i++) {    // for each connection to that node...
                    let c = node.getConnection(i);
                    if (c.getBranch() < 0) {   // has not yet been assigned a current
                        let endBranch = false;
                        const branchComponents = [];
                        let t = node;
                        while (!endBranch) {
                            branchComponents.push(c);
                            c.setBranch(this.numBranches);
                            // get other end of component and set equal to nextTerminal
                            let nextTerminal = c.getEndPt1();
                            if (nextTerminal === t) {
                                nextTerminal = c.getEndPt2();
                            }
                            if (nextTerminal.numConnections() < 2) {   // a dead end in the circuit...
                                endBranch = true;
                                for (let deadEnd of branchComponents) {  // set dead-end branch components to branch 999
                                    deadEnd.setBranch(999);
                                }
                                this.numBranches--;    // so that branch number can get reused
                                break;
                            }
                            c.setCurrentDirection(nextTerminal);
                            if (nextTerminal.numConnections() > 2) {   // have reached another junction
                                endBranch = true;
                            }
                            else {   // move on to the next terminal and next component within the branch
                                t = nextTerminal;
                                let nextComponent = t.getConnection(0);
                                if (nextComponent === c) {
                                    nextComponent = t.getConnection(1);
                                }
                                c = nextComponent;
                            }
                        }
                        this.numBranches++;
                    }
                }
            }
        }
        // Any component that is not attached to the main circuit gets assigned branch #999
        for (let c of this.components) {
            if (c.getBranch() === -1) {
                c.setBranch(999);
            }
        }
        return true;
    }

    /**
     * If a circuit has dead-ends, this method removes the last component in a dead-end branch.
     * @return Component: If a component is removed, returns a wire that has same endpoints as
     *                    removed component; returns null otherwise.
     */
    removeDangler() {
        for (let i = this.components.length - 1; i >= 0; i--) {   // Loop through all circuit components from right end of list
            const component = this.components[i];

            // If either end of component is connected to only one component (i.e. itself), then it's a dangler
            const endPt1Connections = component.getEndPt1().getConnections();
            const endPt2Connections = component.getEndPt2().getConnections();
            if (endPt1Connections.length === 1 || endPt2Connections.length === 1) {
                const componentCopy = new Wire();
                componentCopy.setEndPt1(component.getEndPt1());
                componentCopy.setEndPt2(component.getEndPt2());
                this.removeComponent(component);
                return componentCopy;
            }
        }
        return null;
    }

    /**
     * Adds a component to a to a specific location in a circuit. Ordinarily this is performed only when first specifying
     * the circuit. If a different component already exists at the specified location, this method has no effect.
     * Updates the endpoints of the component so that it knows what terminals it is connected to. Updates those
     * terminals so that they know they are connected to this component. If the component is a battery, this method defaults to
     * making endPoint1 the positive terminal of the battery.
     * @param c  The component to be added
     * @param r1  Endpoint 1's row
     * @param c1  Endpoint 1's column
     * @param r2 Endpoint 2's row
     * @param c2  Endpoint 2's column
     * return  True if component is successfully added to circuit; false if the component was not added
     */
    addComponent(c, r1, c1, r2, c2) {
        c.setEndPt1(this.terminals[r1][c1]);
        c.setEndPt2(this.terminals[r2][c2]);
        // Check wheter a component already exists at this location
        if (this.findCorrespondingComponent(this, c) !== null) {
            return false;
        }
        this.components.push(c);
        this.terminals[r1][c1].connect(c);
        this.terminals[r2][c2].connect(c);
        if (c instanceof Battery) {
            c.setPosEnd(this.terminals[r1][c1]);
        }
        return true;
    }

    /**
     * Like addComponent, but used only for batteries.
     * @param b  Battery: The battery to be added
     * @param r1  int: Endpoint 1's row
     * @param c1  int: Endpoint 1's column
     * @param r2 int: Endpoint 2's row
     * @param c2  int: Endpoint 2's column
     * @param posEndRow  int: Positive terminal's row
     * @param posEndCol  int: Positive terminal's column
     * return  True if component is successfully added to circuit; false if the component was not added
     */
    addBattery(b, r1, c1, r2, c2, posEndRow, posEndCol) {
        b.setEndPt1(this.terminals[r1][c1]);
        b.setEndPt2(this.terminals[r2][c2]);
        // Check wheter a component already exists at this location
        if (this.findCorrespondingComponent(this, b) !== null) {
            return false;
        }
        this.components.push(b);
        this.terminals[r1][c1].connect(b);
        this.terminals[r2][c2].connect(b);
        b.setPosEnd(this.terminals[posEndRow][posEndCol]);
        return true;
    }

    /**
     * Given a component (givenComp) in one circuit (or about to be added in one circuit),
     * this method finds the component attached to the same terminals
     * in a different circuit (circ). If there is not a component attached to the same terminals, this returns null.
     * @param circ  Circuit: The circuit you are searching in
     * @param givenComp  Component: The component from the original circuit
     * @return  Component: The component that is found connected to the same terminals as comp, but in a different circuit, circ,
     *          or null if no such component exists in circ
     */
    findCorrespondingComponent(circ, givenComp) {
        for (let comp of circ.getComponents()) {
            if ( (comp.getEndPt1().equals(givenComp.getEndPt1()) && comp.getEndPt2().equals(givenComp.getEndPt2())) || (comp.getEndPt1().equals(givenComp.getEndPt2()) && comp.getEndPt2().equals(givenComp.getEndPt1())) ) {
                return comp;
            }
        }
        return null;
    }

    /**
     * Removes a component from a given location in a circuit.  This method can be used in the process
     * of desiging a circuit. It also gets used on a copy of the original circuit while identifying independent loops.
     * @param r1  int: One endpoint's row.
     * @param c1  int: One endpoint's column
     * @param r2  int: The other endpoint's row
     * @param c2  int: The other endpoint's column
     */
    removeComponentAt(r1, c1, r2, c2) {
        const component = this.getComponent(r1, c1, r2, c2);
        this.removeComponent(component);
    }

    /**
     * Removes the given component from a circuit. This method can be used in the process
     * of desiging a circuit. It also gets used on a copy of the original circuit while identifying independent loops.
     * @param component  Component: The component to be removed.
     */
    removeComponent(component) {
        const index = this.components.indexOf(component);
        if (index > -1) {
            this.components.splice(index, 1);  // removes one element starting at index
        }
        component.getEndPt1().disconnect(component);
        component.getEndPt2().disconnect(component);
        component.setEndPt1(null);
        component.setEndPt2(null);
    }

    /**
     * Returns the component from a specified location in a circuit.
     * @param r1  int: One endpoint's row
     * @param c1  int: One endpoint's column
     * @param r2  int: The other endpoint's row
     * @param c2  int: The other endpoint's column
     * @return  Returns the component found at that location or null if no component is at that location.
     */
    getComponent(r1, c1, r2, c2) {
        for (let c of this.components) {
            if ( c.getEndPt1().equals(this.terminals[r1][c1]) && c.getEndPt2().equals(this.terminals[r2][c2]) || c.getEndPt2().equals(this.terminals[r1][c1]) && c.getEndPt1().equals(this.terminals[r2][c2]) ) {
                return c;
            }
        }
        return null;
    }

    /**
     * @param row  int: The row of the desired terminal
     * @param col  int: The column of the desired terminal.
     * @return  Terminal: Returns the teminal at the specified location.
     */
    getTerminal(row, col) {
        return this.terminals[row][col];
    }

    /**
     * @return  int: Returns the number of rows of terminals in the circuit
     */
    getRows() {
        return this.rows;
    }

    /**
     * @return  int: Returns the number of columns of terminals in the circuit
     */
    getCols() {
        return this.cols;
    }

    /**
     * @return  int: Returns the number independent branches in the circuit, excluding any branches that do not form complete circuits
     */
    getNumBranches() {
        return this.numBranches;
    }

    /**
     * @return  Terminal[]: Returns a reference to the 2D array of terminals in the circuit
     */
    getTerminals() {
        return this.terminals;
    }

    /**
     * @return  Component[]: Returns a reference to the ArrayList of components in the circuit
     */
    getComponents() {
        return this.components;
    }
}
