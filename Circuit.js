/**
 * Holds the components and terminals for an electric circuit. The solve() method finds the current through
 * and voltage across each component of the circuit. Handles dead-end branches of a circuit correctly,
 * but may not work correctly if circuit fragments or more than one complete circuit are present.
 * Set the instance variable "verbose" to true to display results of intermediate calculations.
 */
class Circuit {
    /**
     * Constructs a new Circuit object with a grid of terminals with particular dimensions
     * @param row The number of rows of terminals in the circuit
     * @param col The number of columns of terminals in the circuit
     */
    constructor(row, col) {
        this.rows = row;
        this.cols = col;
        this.terminals = new Array(this.rows);
        this.components = [];
        this.numBranches = 0;
        this.verbose = true;

        // initialize Terminals
        for (let r = 0; r < this.rows; r++) {
            this.terminals[r] = new Array(this.cols);
            for (let c = 0; c < this.cols; c++) {
                this.terminals[r][c] = new Terminal(r, c);
            }
        }
    }


    /**
     * Constructs a copy of a given circuit by adding in the same set of components. Information regarding
     * branches, currents, etc. will NOT be copied. These can be regenerated by using findNodes(),
     * labelBranches() and solve().
     * @param origCircuit The Circuit object that you wish to copy
     * @return Circuit: A copy of the origCircuit
     */
    clone(origCircuit) {
        const copy = new Circuit(origCircuit.getRows(), origCircuit.getCols());
        for (const comp of origCircuit.getComponents()) {
            // get endpoint row and column for component in original circuit
            const r1 = comp.getEndPt1().getRow();
            const c1 = comp.getEndPt1().getCol();
            const r2 = comp.getEndPt2().getRow();
            const c2 = comp.getEndPt2().getCol();

            if (comp instanceof Resistor) {
                copy.addComponent(new Resistor(comp.getResistance()), r1, c1, r2, c2);
            }
            else if (comp instanceof Wire) {
                copy.addComponent(new Wire(), r1, c1, r2, c2);
            }
            else if (comp instanceof Battery) {
                const batt = new Battery(comp.getVoltage());
                copy.addBattery(batt, r1, c1, r2, c2, comp.getPosEnd().getRow(), comp.getPosEnd().getCol());
            }
        }
        return copy;
    }


    /**
     * This method uses several helper methods to solve a circuit via Kirchhoff's rules and linear algebra.
     * After running it, each component will have been assigned a branch number, current, and a current direction;
     * each Terminal will have a potential.
     * @return  Number[]: Returns an array of currents. Each current is indexed by its branch number
     * within the circuit. Returns null if short circuit or no complete circuit.
     */
    solve() {
        // Re-initialize component values and terminal potentials
        for (let c of this.components) {
            c.setBranch(-1);
            c.setCurrent(0);
            c.setCurrentDirection(null);
        }
        for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {
                this.terminals[r][c].setPotential(Number.MAX_VALUE);
            }
        }

        const nodes = [];
        const loops = [];
        this.numBranches = this.findNodesAndLoops(nodes, loops);    // Originally declared as a local var; think it should be instance var
        if (this.verbose) {
            console.log("Number of nodes: " + nodes.length);
            console.log("Number of loops: " + loops.length);
            console.log("Number of branches: " + this.numBranches);
        }
        if (this.numBranches === 0) {  // No complete circuit
            return null;
        }

        if (this.isShortCircuit()) {
            return null;
        }

        if (this.verbose) {
            console.log("The stored loops are:\n");
            for (let i = 0; i < loops.length; i++) {
                console.log("Loop " + i);
                const loop = loops[i];
                for (let c of loop) {
                    console.log("Loop: " + c + "  branch: " + c.getBranch());
                }
                console.log("\n");
            }
        }

        // ****************************************************
        // Generate equation matrices from nodes and loops.
        let coefficients;  // a 2-D array of Numbers
        let constants;     // a 1-D array of Numbers
        const matrixRows = nodes.length - 1 + loops.length;
        const matrixCols = this.numBranches;
        if (this.numBranches === 1) {
            coefficients = new Array(1);
            coefficients[0] = new Array(1);
            constants = new Array(1);
        }
        else {
            coefficients = new Array(matrixRows).fill().map(() => Array(matrixCols).fill(0));    // coefficient and constant terms for Kirchhoff's rules equations
            constants = new Array(matrixRows);
        }

        if (this.verbose) {
            if (this.numBranches === 1) {
                console.log("Coefficients dimensions are: 1 x 1");
            }
            else {
                console.log("Coefficients dimensions are: " + (matrixRows) + " x " + matrixCols);
            }
        }
        // Get equations from nodes: Kirchoff's junction rule. Coefficients in the equations are all 1's
        // (for currents flowing into the junction) or -1's (for currents that are flowing out of the junction).
        // The constant term for each equation is 0.
        let eqnNum = 0;
        for ( ; eqnNum < nodes.length - 1; eqnNum++) {
            for (let c of nodes[eqnNum].getConnections()) {     // loops through all components connected to this node...
                if (c.getCurrentDirection().equals(nodes[eqnNum])) {  // if the current direction of this component is the same as the node,
                    coefficients[eqnNum][c.getBranch()] = 1;            // then current is flowing into the node
                }
                else {
                    coefficients[eqnNum][c.getBranch()] = -1;             // otherwise it's flowing out of the node
                }
            }
            constants[eqnNum] = 0;
        }
        // Get equations from loops
        const nodeEqns = eqnNum;
        for ( ; eqnNum < loops.length + nodeEqns; eqnNum++) {    // for each loop in circuit...
            loops[eqnNum - nodeEqns].push(loops[eqnNum - nodeEqns][0]); // duplicate the first component at the end of the loop
            let voltageDrop = 0;
            for (let i = 0; i < loops[eqnNum - nodeEqns].length - 1; i++) {  // add voltage drops from each component in the loop
                const c = loops[eqnNum - nodeEqns][i];               // (except the last one, which is a repeat of the first)
                const nextComponent = loops[eqnNum - nodeEqns][i + 1];
                let connectedToNextComponent = false;
                for (let aConnectedComponent of c.getCurrentDirection().getConnections()) {  // Test whether the currentDirection
                    if (nextComponent.equals(aConnectedComponent)) {     // end of the component is connected to the next component in the loop...
                        connectedToNextComponent = true;
                    }
                }
                if (connectedToNextComponent) {  // If so you are walking around the loop in the component's current direction
                    coefficients[eqnNum][c.getBranch()] += c.getResistance();   // so you add the voltage drop.
                }
                else {                           // Walking around loop opposite the "labeled" current direction,
                    coefficients[eqnNum][c.getBranch()] -= c.getResistance();   // so it's a "negative" current and you subtract the voltage drop.
                }
            }

            // The constant term in each loop equation is due to a Voltage gain from a battery. Let's find these
            let voltageGain = 0;
            for (let i = 0; i < loops[eqnNum - nodeEqns].length - 1; i++) {  // go through all components in loop except last one (a repeat of the first)
                const c = loops[eqnNum - nodeEqns][i];
                if (c instanceof Battery) {
                    const nextComponent = loops[eqnNum - nodeEqns][i + 1];
                    let connectedToNextComponent = false;
                    // Determine whether the direction you are walking through the loop is from the neg. to pos. terminal of the battery
                    for (let aConnectedComponent of c.getPosEnd().getConnections()) {
                        if (nextComponent.equals(aConnectedComponent)) {  // if the posive end is connected to the next component in the loop...
                            connectedToNextComponent = true;
                        }
                    }
                    if (connectedToNextComponent) {
                        voltageGain += c.getVoltage();            // then it's a voltage gain. (Walking through battery from neg to pos.)
                    }
                    else {
                        voltageGain -= c.getVoltage();   // Otherwise you are walking around the loop from pos to neg through the battery.
                    }
                }
            }
            constants[eqnNum] = voltageGain;
            loops[eqnNum - nodeEqns].pop();     // Remove the last component from the loop (the duplicate of first component)
        }

        if (this.verbose) {
            // Print coefficient Matrix and Constant vector
            console.log("Coefficients:\n");
            for (let r = 0; r < coefficients.length; r++) {
                for (let c = 0; c < coefficients[r].length; c++) {
                    console.log(coefficients[r][c] + "  ");
                }
                console.log("\n");
            }
            console.log("Constants:\n");
            for (let i = 0; i < constants.length; i++) {
                console.log(constants[i] + "  ");
            }
            console.log("\n");
        }

        // *************************************************************
        // Solve Kirchoff's Rules equation matrix with Gaussian Elimination (see gauss-jordan.js)
        const currents = linearEqnSolve(coefficients, constants);

        //***************************************************************

        // Update component currents
        for (let c of this.components) {
            if (c.getBranch() < 999) {
                c.setCurrent(currents[c.getBranch()]);
            }
            else {
                c.setCurrent(0);
            }
        }

        if (this.verbose) {
            console.log(this);
        }

        this.calculatePotentials(loops, nodes);

        if (this.verbose) {
            console.log("Terminal potentials:");
            for (let r = 0; r < this.rows; r++) {
                for (let c = 0; c < this.cols; c++) {
                    console.log(this.terminals[r][c].getPotential() + "\t");
                }
                console.log("\n");
            }
            console.log("\n");
        }

        return currents;
    }


    /**
     * Identifies if a short circuit exists: i.e. a complete loop with no resistors and at least one battery.
     * @return True if short circuit exists; false otherwise.
     */
    isShortCircuit() {
        let isShort = false;
        const copy = this.clone(this);
        for (let i = copy.getComponents().length - 1; i >= 0; i--) {
            const c = copy.getComponents()[i];
            if (c instanceof Resistor) {
                copy.removeComponent(c);
            }
        }
        const nodes = [];
        const loops = [];
        const copyBranches = copy.findNodesAndLoops(nodes, loops);
        if (copyBranches !== 0) {  // At least one loop found
            for (let loop of loops) {
                for (let c of loop) {
                    if (c instanceof Battery) {
                        isShort = true;
                    }
                }
            }
        }
        return isShort;
    }


    /**
     * This method uses helper methods to:
     *     (1) populate the Array of nodes (junctions) for a circuit;
     *     (2) assign a current/branch number to each independent branch of the circuit; dead-ends are branch 999
     *     (3) assign a current-direction to each component within each branch;
     *     (4) populate an array of loops, wherein each loop is an array of the components in that loop;
     * @param nodes  Terminal[]: An empty array that will be populated with the terminals that are junctions in the circuit.
     * @param origloops  Component[][]: An empty array of arrays of components that will be populated with components from circuit loops.
     * @return int: The number of branches in the circuit, excluding any dead-end branches.
     */
    findNodesAndLoops(nodes, origLoops) {
        // Original circuit, including any dead-ends
        this.findNodes(nodes);
        this.labelBranches(nodes);
        if (this.numBranches === 0) {  // There is not a complete circuit
            return 0;
        }
        // A copy of the circuit that will have dead-ends removed.
        const equationCopy = this.clone(this);
        equationCopy.findNodes(nodes);
        equationCopy.labelBranches(nodes);
        let deadEnd = equationCopy.getComponents()[0]; // just to be not null
        while (deadEnd !== null) {  // Remove one dangling component at a time, until there are no more
            deadEnd = equationCopy.removeDangler();
            if (deadEnd !== null) {
                const orig = equationCopy.findCorrespondingComponent(this, deadEnd);
                orig.setBranch(999);
            }
        }

        equationCopy.findNodes(nodes);  // The nodes list is now properly updated for writing circuit equations.
        equationCopy.labelBranches(nodes);

        // Update original circuit with branch numbers and currentDirections from the copy that has had deadends trimmed off.
        for (let c of equationCopy.getComponents()) {
            const orig = this.findCorrespondingComponent(this, c);
            orig.setBranch(c.getBranch());
            orig.setCurrentDirection(c.getCurrentDirection());
        }

        // Make a copy of circuit and nodes that can be modified during the loop analysis. As loops are identified,
        // components will be removed from the copy circuit, so that different loops can be found.
        const copy = this.clone(equationCopy);
        const copyNodes = [];
        copy.findNodes(copyNodes);
        copy.labelBranches(copyNodes);

        this.numBranches = copy.getNumBranches();

        // Makes an array parallel to origLoops: an array of arrays of components within each loop.
        const copyLoops = []; // loops in the copy circuit, not the original circuit
        let loopCounter = 0;
        while (copy.getComponents().length > 0) {
            copyLoops.push([]);
            origLoops.push([]);
            //  make array of terminals in loop
            const copyTerms = [];
            let comp = copy.getComponents()[0];
            let prevTerm = comp.getEndPt1();
            copyTerms.push(prevTerm);
            let endLoop = false;
            while (!endLoop) {
                //walk around loop, adding terminals and components to their arrays
                copyLoops[loopCounter].push(comp);
                origLoops[loopCounter].push(this.findCorrespondingComponent(this, comp));  // corresponding component in orig circuit
                let nextTerm = comp.getEndPt2();
                if (nextTerm === prevTerm) {  // then nextTerm is not actually the next terminal in the loop...
                    nextTerm = comp.getEndPt1();    // so get the other end of the component
                }

                if (copyTerms.includes(nextTerm)) {  // you have reached a terminal you have seen before
                    endLoop = true;
                }
                else {   // get one of the connected components (that is not the component you just added to the loop)
                    let nextComp = nextTerm.getConnections()[0];
                    if (comp === nextComp) {
                        nextComp = nextTerm.getConnections()[1];
                    }
                    prevTerm = nextTerm;
                    comp = nextComp;
                }
                copyTerms.push(nextTerm);
            }
            // Once you find a terminal that is already in the loop, there may still be a dangling end at the start of the loop.
            // That is, it may be shaped like a "9". So trim off the initial components until the start and end terminals are the same.
            while (copyTerms[0] !== copyTerms[copyTerms.length - 1]) {
                //trim terminals and components off start of lists
                copyTerms.shift();
                copyLoops[loopCounter].shift();
                origLoops[loopCounter].shift();
            }
            // To find the next independent loop, remove a component (and dangling ends) from the loop you just found.
            // That way you won't find the exact same loop the next time.
            copy.removeComponent(copyLoops[loopCounter][0]);
            let dangler = copy.getComponents()[0]; // just to be not null;
            while (dangler !== null) {   // Remove one dangling component at a time, until there are no more
                dangler = copy.removeDangler();
            }
            loopCounter++;
        }
        return copy.getNumBranches();
    }


    /**
     * Searches the 2-D array of terminals to find junctions. Adds any terminals that have three or more connections
     * to a List of nodes. The provided list of nodes is first cleared, and then repopulated.
     * @param nodes  A reference to a List of terminals.
     */
    findNodes(nodes) {
        nodes.splice(0, nodes.length);  // empties the nodes array
        for (let r = 0; r < this.getRows(); r++) {
            for (let c = 0; c < this.getCols(); c++) {
                if (this.getTerminal(r, c).numConnections() > 2) {
                    nodes.push(this.getTerminal(r, c));
                }
            }
        }
    }


    /**
     * Labels each component in the circuit with a branch number. The currents through all components in a branch are the same,
     * so branch numbers correspond to current variables in the circuit equations. E.g. current[0] = current through components
     * labeled with branch 0. This method also assigns a current direction to each component within a branch. Branches that are
     * dead-ends are given the branch number 999. (May not identify all deadends.)
     * @param nodes  Array of Terminals: The List of nodes (junctions) in the circuit.
     * @return False if it finds no complete circuit; true otherwise.
     */
    labelBranches(nodes) {
        this.numBranches = 0;
        if (this.components.length === 0) {
            return false;
        }
        if (nodes.length === 0) {   // Circuit is a single loop without junctions (or a single incomplete circuit)
            let c = this.components[0];
            let prevTerm = c.getEndPt1();
            for (let i = 0; i < this.components.length; i++) {
                c.setBranch(0);     // only one loop, so all components are branch 0
                let nextTerminal = c.getEndPt2();
                if (nextTerminal === prevTerm) {   // make sure you get the terminal at the opposite end of the component
                    nextTerminal = c.getEndPt1();
                }
                if (nextTerminal.numConnections() < 2) {   // a dead end in the circuit
                    return false;
                }
                c.setCurrentDirection(nextTerminal);
                let nextComponent = nextTerminal.getConnection(0);
                if (nextComponent === c) {
                    nextComponent = nextTerminal.getConnection(1);
                }
                c = nextComponent;
                prevTerm = nextTerminal;
            }
            this.numBranches = 1;    // the complete loop is one branch: branch #0
        }
        else {   // there are multiple branches
            // Reset branch number of each component to -1, the default for unassigned branches
            for (let c of this.components) {
                c.setBranch(-1);
            }
            // loop through every connection of every node...
            for (let node of nodes) {
                for (let i = 0; i < node.numConnections(); i++) {    // for each connection to that node...
                    let c = node.getConnection(i);
                    if (c.getBranch() < 0) {   // has not yet been assigned a current
                        let endBranch = false;
                        const branchComponents = [];
                        let t = node;
                        while (!endBranch) {
                            branchComponents.push(c);
                            c.setBranch(this.numBranches);
                            // get other end of component and set equal to nextTerminal
                            let nextTerminal = c.getEndPt1();
                            if (nextTerminal === t) {
                                nextTerminal = c.getEndPt2();
                            }
                            if (nextTerminal.numConnections() < 2) {   // a dead end in the circuit...
                                endBranch = true;
                                for (let deadEnd of branchComponents) {  // set dead-end branch components to branch 999
                                    deadEnd.setBranch(999);
                                }
                                this.numBranches--;    // so that branch number can get reused
                                break;
                            }
                            c.setCurrentDirection(nextTerminal);
                            if (nextTerminal.numConnections() > 2) {   // have reached another junction
                                endBranch = true;
                            }
                            else {   // move on to the next terminal and next component within the branch
                                t = nextTerminal;
                                let nextComponent = t.getConnection(0);
                                if (nextComponent === c) {
                                    nextComponent = t.getConnection(1);
                                }
                                c = nextComponent;
                            }
                        }
                        this.numBranches++;
                    }
                }
            }
        }
        // Any component that is not attached to the main circuit gets assigned branch #999
        for (let c of this.components) {
            if (c.getBranch() === -1) {
                c.setBranch(999);
            }
        }
        return true;
    }


    /**
     * If a circuit has dead-ends, this method removes the last component in a dead-end branch.
     * @return Component: If a component is removed, returns a wire that has same endpoints as
     *                    removed component; returns null otherwise.
     */
    removeDangler() {
        for (let i = this.components.length - 1; i >= 0; i--) {   // Loop through all circuit components from right end of list
            const component = this.components[i];

            // If either end of component is connected to only one component (i.e. itself), then it's a dangler
            const endPt1Connections = component.getEndPt1().getConnections();
            const endPt2Connections = component.getEndPt2().getConnections();
            if (endPt1Connections.length === 1 || endPt2Connections.length === 1) {
                const componentCopy = new Wire();
                componentCopy.setEndPt1(component.getEndPt1());
                componentCopy.setEndPt2(component.getEndPt2());
                this.removeComponent(component);
                return componentCopy;
            }
        }
        return null;
    }


    /**
     * Sets the potential at each terminal in the circuit. Disconnected terminals are left at their default potental
     * of Number.MAX_VALUE.
     * @param loops  An array of the arrays of components in each circuit loop
     * @param nodes  An array of the circuit nodes/junctions
     */
    calculatePotentials(loops, nodes) {
        // Find a terminal in a loop; assign it potential 0
        const comp = loops[0][0];
        comp.getEndPt1().setPotential(0);

        // Make a copy of the circuit components. Loop through all copied components finding those that have a potential set at only one end.
        // Then calculate and set potential for the other end and remove that component from the copy List.
        const componentsCopy = [];
        for (let c of this.components) {
            componentsCopy.push(c);
        }

        let updateOccurred = true;
        while (updateOccurred) {
            updateOccurred = false;
            for (let i  = 0; i < componentsCopy.length; i++) {
                const c = componentsCopy[i];
                const potential1 = c.getEndPt1().getPotential();
                const potential2 = c.getEndPt2().getPotential();
                if (potential1 < Number.MAX_VALUE / 10 && potential2 >= Number.MAX_VALUE / 10 || potential2 < Number.MAX_VALUE / 10 && potential1 >= Number.MAX_VALUE / 10) {
                    // Other end's potential is known end's potential + component's voltage gain
                    let knownEnd = c.getEndPt1();
                    let otherEnd = c.getEndPt2();
                    if (knownEnd.getPotential() >= Number.MAX_VALUE / 10) {
                        knownEnd = c.getEndPt2();
                        otherEnd = c.getEndPt1();
                    }

                    if (c instanceof Battery) {
                        if ( knownEnd.equals(c.getPosEnd()) ) {
                            otherEnd.setPotential(knownEnd.getPotential() - c.getVoltage());
                        }
                        else {
                            otherEnd.setPotential(knownEnd.getPotential() + c.getVoltage());
                        }
                    }
                    else {
                        if (c.getBranch() < 999) {
                            if (c.getCurrentDirection() !== null && c.getCurrentDirection().equals(knownEnd)) {
                                otherEnd.setPotential(knownEnd.getPotential() + c.getResistance() * c.getCurrent());
                            }
                            else {
                                otherEnd.setPotential(knownEnd.getPotential() - c.getResistance() * c.getCurrent());
                            }
                        }
                        else {
                            otherEnd.setPotential(knownEnd.getPotential());
                        }
                    }
                    updateOccurred = true;
                    componentsCopy.splice(i, 1);
                    break;
                }
            }
        }

        // Add or subtract to all the potentials so that the minimum potential is 0 Volts
        let minVolts = this.terminals[0][0].getPotential();
        for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {
                if (this.terminals[r][c].getPotential() < minVolts) {
                    minVolts = this.terminals[r][c].getPotential();
                }
            }
        }
        for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {
                if (this.terminals[r][c].getPotential() !== Number.MAX_VALUE) {
                    this.terminals[r][c].setPotential(this.terminals[r][c].getPotential() - minVolts);
                }
            }
        }

        // Loop through any remaining components in componentsCopy. If their terminal potentials are still Double.MAX_VALUE,
        // set them to 0. These would be components not connected to any complete circuit.
        // This may not be correct, since these components may include a battery, or even a separate complete circuit...
        for (let c of componentsCopy) {
            if (c.getEndPt1().getPotential() >= Number.MAX_VALUE / 10) {
                c.getEndPt1().setPotential(0);
                c.getEndPt2().setPotential(0);
            }
        }
    }


    /**
     * Adds a component to a to a specific location in a circuit. Ordinarily this is performed only when first specifying
     * the circuit. If a different component already exists at the specified location, this method has no effect.
     * Updates the endpoints of the component so that it knows what terminals it is connected to. Updates those
     * terminals so that they know they are connected to this component. If the component is a battery, this method defaults to
     * making endPoint1 the positive terminal of the battery.
     * @param c  The component to be added
     * @param r1  Endpoint 1's row
     * @param c1  Endpoint 1's column
     * @param r2 Endpoint 2's row
     * @param c2  Endpoint 2's column
     * return  True if component is successfully added to circuit; false if the component was not added
     */
    addComponent(c, r1, c1, r2, c2) {
        c.setEndPt1(this.terminals[r1][c1]);
        c.setEndPt2(this.terminals[r2][c2]);
        // Check wheter a component already exists at this location
        if (this.findCorrespondingComponent(this, c) !== null) {
            return false;
        }
        this.components.push(c);
        this.terminals[r1][c1].connect(c);
        this.terminals[r2][c2].connect(c);
        if (c instanceof Battery) {
            c.setPosEnd(this.terminals[r1][c1]);
        }
        return true;
    }


    /**
     * Like addComponent, but used only for batteries.
     * @param b  Battery: The battery to be added
     * @param r1  int: Endpoint 1's row
     * @param c1  int: Endpoint 1's column
     * @param r2 int: Endpoint 2's row
     * @param c2  int: Endpoint 2's column
     * @param posEndRow  int: Positive terminal's row
     * @param posEndCol  int: Positive terminal's column
     * return  True if component is successfully added to circuit; false if the component was not added
     */
    addBattery(b, r1, c1, r2, c2, posEndRow, posEndCol) {
        b.setEndPt1(this.terminals[r1][c1]);
        b.setEndPt2(this.terminals[r2][c2]);
        // Check wheter a component already exists at this location
        if (this.findCorrespondingComponent(this, b) !== null) {
            return false;
        }
        this.components.push(b);
        this.terminals[r1][c1].connect(b);
        this.terminals[r2][c2].connect(b);
        b.setPosEnd(this.terminals[posEndRow][posEndCol]);
        return true;
    }


    /**
     * Given a component (givenComp) in one circuit (or about to be added in one circuit),
     * this method finds the component attached to the same terminals
     * in a different circuit (circ). If there is not a component attached to the same terminals, this returns null.
     * @param circ  Circuit: The circuit you are searching in
     * @param givenComp  Component: The component from the original circuit
     * @return  Component: The component that is found connected to the same terminals as comp, but in a different circuit, circ,
     *          or null if no such component exists in circ
     */
    findCorrespondingComponent(circ, givenComp) {
        for (let comp of circ.getComponents()) {
            if ( (comp.getEndPt1().equals(givenComp.getEndPt1()) && comp.getEndPt2().equals(givenComp.getEndPt2())) || (comp.getEndPt1().equals(givenComp.getEndPt2()) && comp.getEndPt2().equals(givenComp.getEndPt1())) ) {
                return comp;
            }
        }
        return null;
    }


    /**
     * Removes a component from a given location in a circuit.  This method can be used in the process
     * of desiging a circuit. It also gets used on a copy of the original circuit while identifying independent loops.
     * @param r1  int: One endpoint's row.
     * @param c1  int: One endpoint's column
     * @param r2  int: The other endpoint's row
     * @param c2  int: The other endpoint's column
     */
    removeComponentAt(r1, c1, r2, c2) {
        const component = this.getComponent(r1, c1, r2, c2);
        this.removeComponent(component);
    }


    /**
     * Removes the given component from a circuit. This method can be used in the process
     * of desiging a circuit. It also gets used on a copy of the original circuit while identifying independent loops.
     * @param component  Component: The component to be removed.
     */
    removeComponent(component) {
        const index = this.components.indexOf(component);
        if (index > -1) {
            this.components.splice(index, 1);  // removes one element starting at index
        }
        component.getEndPt1().disconnect(component);
        component.getEndPt2().disconnect(component);
        component.setEndPt1(null);
        component.setEndPt2(null);
    }


    /**
     * Returns the component from a specified location in a circuit.
     * @param r1  int: One endpoint's row
     * @param c1  int: One endpoint's column
     * @param r2  int: The other endpoint's row
     * @param c2  int: The other endpoint's column
     * @return  Returns the component found at that location or null if no component is at that location.
     */
    getComponent(r1, c1, r2, c2) {
        for (let c of this.components) {
            if ( c.getEndPt1().equals(this.terminals[r1][c1]) && c.getEndPt2().equals(this.terminals[r2][c2]) || c.getEndPt2().equals(this.terminals[r1][c1]) && c.getEndPt1().equals(this.terminals[r2][c2]) ) {
                return c;
            }
        }
        return null;
    }


    /**
     * @param row  int: The row of the desired terminal
     * @param col  int: The column of the desired terminal.
     * @return  Terminal: Returns the teminal at the specified location.
     */
    getTerminal(row, col) {
        return this.terminals[row][col];
    }


    /**
     * @return  int: Returns the number of rows of terminals in the circuit
     */
    getRows() {
        return this.rows;
    }


    /**
     * @return  int: Returns the number of columns of terminals in the circuit
     */
    getCols() {
        return this.cols;
    }


    /**
     * @return  int: Returns the number independent branches in the circuit, excluding any branches that do not form complete circuits
     */
    getNumBranches() {
        return this.numBranches;
    }


    /**
     * @return  Terminal[]: Returns a reference to the 2D array of terminals in the circuit
     */
    getTerminals() {
        return this.terminals;
    }


    /**
     * @return  Component[]: Returns a reference to the ArrayList of components in the circuit
     */
    getComponents() {
        return this.components;
    }
}
